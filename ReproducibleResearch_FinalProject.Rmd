---
title: 'Reproducible Research: Final Project'
author: "Alejandro Osorio"
date: "September 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

## Excecutive Summary

### Results Obtained

## Appendix 1: Methodology

### Measuring harm to population health

Harm to population health was quantified through the total number of deceased and injured human beings, caused by each event.  For that purpose, variables 'FATALITIES' and 'INJURIES' were used as total numbers of each type of harm, for each event.

### Measuring economic damage

Economic damage was quantified calculating the total of US Dollars lost due to damaged properties or crops.  Variables 'PROPDMG' and 'CROPDMG' (dimensions of total damage to properties and crops respectivelly), plus 'PROPDMGEXP' and 'COPDMGEXP' (magnitude of the previous dimensions).  Detailed calculations in Appendix 2.

### Final variables required

PENDIENTE

## Appendix 2: Getting and Preparing Dataset

### 1. Reading Data
```{r cars, cache = TRUE, results = "hide"}
dataoriginal <- read_csv("repdata%2Fdata%2FStormData.csv")
```

### 2. Preparing Dataset

#### a. Subsetting and identifying variables without NAs

The subset that was passed on for further cleaning (variables defined in Apendix 1), was:
```{r}
datafinal <- select(dataoriginal, c(2,5,7,8, 23:28))
```

Variables without NAs:
```{r}
which(colSums(is.na(datafinal)) == 0)
```

Fortunately, almost all variables required by the methodology (besides 'PROPDMGEXP' and 'CROPDMGEXP') were complete.

#### b. 'PROPDMGEXP' and 'CROPDMGEXP' cleaning

##### First cleaning

These two variables contained NAs.  Now, if NAs in these variables were asociated with a zero value on their corresponding 'PROPDMG' and 'CROPDMG' variables, they were considered complete (zero times any magnitude is zero). Therefore: 

```{r}
incompletedmg <- with(datafinal, which((is.na(PROPDMGEXP) & PROPDMG != 0) | (is.na(CROPDMGEXP) & CROPDMG != 0))) 
incompletedmg
```

Only 79 rows had either a 'PROPDMG' or 'CROPDMG' variable with a non zero value and an NA magnitude.  These rows were therefore eliminated from the dataset, as follows:

```{r}
datafinal <- datafinal[-incompletedmg,]
```

Final check:
```{r}
with(datafinal, which((is.na(PROPDMGEXP) & PROPDMG != 0)|is.na(CROPDMGEXP) & CROPDMG != 0))
```

So no values with NA magnitudes were left.

##### Further cleaning

When preparing to create unique numeric variables for property and crop damage (ie: one '1.000' variable instead of '1' and 'K' variables), the following situation was identified for the magnitudes' values:

PROPDMGEXP:
```{r}
table(datafinal$PROPDMGEXP, useNA = "always")
```

CROPDMGEXP:
```{r}
table(datafinal$CROPDMGEXP, useNA = "always")
```

So further cleaning was required in order to end up with only "K", "M" or "B" values.

First, lowercase "k" and "m" values were replaced by uppercase values in both variables, as follows:
```{r}
datafinal$PROPDMGEXP[which(datafinal$PROPDMGEXP == "m")] <- "M"
datafinal$CROPDMGEXP[which(datafinal$CROPDMGEXP == "k")] <- "K"
datafinal$CROPDMGEXP[which(datafinal$CROPDMGEXP == "m")] <- "M"
```

Finally, rows in which either 'PROPDMGEXP' or 'CROPDMGEXP' had values other than "K", "M", "B" or NA, were eliminated, as follows:
```{r}
wrongdmgexp <- with(datafinal, which(!(PROPDMGEXP %in% c("K", "M", "B", NA)) | !(CROPDMGEXP %in% c("K", "M", "B", NA))))
datafinal <- datafinal[-wrongdmgexp,]
length(wrongdmgexp)
```

With only the above number of eliminated rows.

#### c. 'EVTYPE' cleaning

Dimensioning number of unique values for this variable:
```{r}
glimpse(unique(datafinal$EVTYPE))
```

Given the humongous diversity of values (973), a table view was applied in order to get a glipmse of the situation, as follows:
```{r}
head(data.frame(table(datafinal$EVTYPE)), 15)
```

As suspected, just out of the first 15 results it could be concluded that no standardized values were contained within that variable (for example, 'beach erosion' was written three different ways, including one misspelled version).

In order to simplify the unavoidable required value-standartization, unique values with a frecuency of 10 or less, were identified and arranged as follows:
```{r}
lowfreqevtype <- datafinal$EVTYPE %>% table() %>% data.frame() %>% filter(., Freq <= 10) %>% arrange(., desc(Freq)) %>% glimpse()
```

So 814 low frequency value types out of 973, reduced the total number down to 159, involving the following number of rows:
```{r}
sum(lowfreqevtype$Freq)
```

 Eliminating said rows:
 

#### d. Creating variables with numeric values for property and crop damage


## Appendix 2: Preliminary Analysis

## Appendix 3: 

